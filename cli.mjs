#!/usr/bin/env node
/**
 * cc-review-queue
 * Show files that need human review after AI edits.
 * Reads activity-log.jsonl (from activity-logger hook).
 */
import { readFileSync, existsSync } from 'fs';
import { homedir } from 'os';
import { resolve } from 'path';

const args = process.argv.slice(2);
const flags = {
  log: args.find(a => a.startsWith('--log='))?.slice(6) || '~/ops/activity-log.jsonl',
  days: parseInt(args.find(a => a.startsWith('--days='))?.slice(7) ?? '30'),
  all: args.includes('--all'),
  format: args.find(a => a.startsWith('--format='))?.slice(9) || 'plain',
  top: parseInt(args.find(a => a.startsWith('--top='))?.slice(6) ?? '20'),
  help: args.includes('--help') || args.includes('-h'),
};

if (flags.help) {
  console.log(`cc-review-queue â€” Show files changed by AI that need human review

Usage:
  npx cc-review-queue              Last 30 days (default)
  npx cc-review-queue --all        All time
  npx cc-review-queue --days=7     Last 7 days
  npx cc-review-queue --top=10     Show top 10 files
  npx cc-review-queue --format=md  Markdown output

Options:
  --log=PATH     Activity log path (default: ~/ops/activity-log.jsonl)
  --days=N       Look back N days (default: 30)
  --all          Include all time (ignores --days)
  --top=N        Show top N files (default: 20)
  --format=md    Output as Markdown
  --help         Show this help`);
  process.exit(0);
}

const logPath = resolve(flags.log.replace('~', homedir()));

if (!existsSync(logPath)) {
  console.error(`âœ— Log not found: ${logPath}`);
  console.error(`  Run the activity-logger hook first, or set --log=PATH`);
  process.exit(1);
}

// Parse log
const lines = readFileSync(logPath, 'utf8').trim().split('\n').filter(Boolean);
const entries = [];
for (const line of lines) {
  try {
    const e = JSON.parse(line);
    if (e.needs_review === true) entries.push(e);
  } catch {}
}

// Filter by date
const cutoff = flags.all ? 0 : Date.now() - flags.days * 86400_000;
const filtered = flags.all
  ? entries
  : entries.filter(e => {
      const ts = e.ts_epoch ? e.ts_epoch * 1000 : new Date(e.ts).getTime();
      return ts >= cutoff;
    });

if (filtered.length === 0) {
  const period = flags.all ? 'all time' : `last ${flags.days} days`;
  console.log(`âœ“ No items pending review (${period})`);
  process.exit(0);
}

// Group by file path â€” keep most recent edit per file, sum add/del
const byPath = new Map();
for (const e of filtered) {
  const path = e.path || e.file || '(unknown)';
  const ts = e.ts_epoch ? e.ts_epoch * 1000 : new Date(e.ts).getTime();
  if (!byPath.has(path)) {
    byPath.set(path, { path, tool: e.tool, lastTs: ts, lastDate: e.ts, totalAdd: 0, totalDel: 0, editCount: 0 });
  }
  const rec = byPath.get(path);
  rec.totalAdd += (e.add || 0);
  rec.totalDel += (e.del || 0);
  rec.editCount++;
  if (ts > rec.lastTs) {
    rec.lastTs = ts;
    rec.lastDate = e.ts;
    rec.tool = e.tool;
  }
}

// Sort by most recently edited
const sorted = [...byPath.values()].sort((a, b) => b.lastTs - a.lastTs).slice(0, flags.top);

// Format date
function fmtDate(isoStr) {
  const d = new Date(isoStr);
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  const h = String(d.getHours()).padStart(2, '0');
  const min = String(d.getMinutes()).padStart(2, '0');
  return `${y}-${m}-${day} ${h}:${min}`;
}

// Shorten path
function shortPath(p) {
  const home = homedir();
  return p.startsWith(home) ? '~' + p.slice(home.length) : p;
}

// Summarize change
function changeSummary(add, del) {
  const parts = [];
  if (add > 0) parts.push(`+${add}`);
  if (del > 0) parts.push(`-${del}`);
  return parts.length ? parts.join(' / ') : 'no changes';
}

const period = flags.all ? 'all time' : `last ${flags.days} days`;
const totalFiles = byPath.size;
const totalEdits = filtered.length;
const totalAdded = filtered.reduce((s, e) => s + (e.add || 0), 0);
const totalDeleted = filtered.reduce((s, e) => s + (e.del || 0), 0);

if (flags.format === 'md') {
  // Markdown output
  console.log(`# AI Review Queue\n`);
  console.log(`Period: ${period} Â· ${totalFiles} files Â· ${totalEdits} edits Â· +${totalAdded} / -${totalDeleted} lines\n`);
  console.log(`| # | Last Edit | Tool | File | Changes | Edits |`);
  console.log(`|---|-----------|------|------|---------|-------|`);
  sorted.forEach((r, i) => {
    const n = i + 1;
    const date = fmtDate(r.lastDate);
    const p = shortPath(r.path);
    const ch = changeSummary(r.totalAdd, r.totalDel);
    console.log(`| ${n} | ${date} | ${r.tool || 'Edit'} | \`${p}\` | ${ch} | ${r.editCount}x |`);
  });
  if (totalFiles > flags.top) {
    console.log(`\n_...and ${totalFiles - flags.top} more files_`);
  }
  console.log(`\n---`);
  console.log(`_Generated by [cc-review-queue](https://github.com/yurukusa/cc-review-queue)_`);
} else {
  // Plain text output
  console.log(`ðŸ“‹ AI Review Queue â€” ${period}`);
  console.log(``);
  console.log(`  ${totalFiles} files pending review Â· ${totalEdits} edits Â· +${totalAdded}/-${totalDeleted} lines`);
  console.log(``);

  sorted.forEach((r, i) => {
    const n = String(i + 1).padStart(2, ' ');
    const date = fmtDate(r.lastDate);
    const p = shortPath(r.path);
    const ch = changeSummary(r.totalAdd, r.totalDel);
    const tool = (r.tool || 'Edit').toUpperCase().padEnd(5, ' ');
    const ec = r.editCount > 1 ? ` (${r.editCount}x)` : '';
    console.log(`  ${n}. ${date}  [${tool}]  ${p}`);
    console.log(`      ${ch}${ec}`);
  });

  if (totalFiles > flags.top) {
    console.log(``);
    console.log(`  ...and ${totalFiles - flags.top} more files (use --top=N to see more)`);
  }

  console.log(``);
  console.log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
  console.log(`  To prevent risky edits: cc-health-check â†’ Ops Kit`);
  console.log(`  https://yurukusa.github.io/cc-health-check/`);
}
